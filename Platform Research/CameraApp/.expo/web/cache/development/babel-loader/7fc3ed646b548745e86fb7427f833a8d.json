{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\nimport { PitchCorrectionQuality } from \"./AV.types\";\nexport var _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 500;\nexport var _DEFAULT_INITIAL_PLAYBACK_STATUS = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false\n};\nexport function getNativeSourceFromSource(source) {\n  var uri = null;\n  var overridingExtension = null;\n  var headers;\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension: overridingExtension,\n      headers: headers\n    };\n  }\n\n  var asset = _getAssetFromPlaybackSource(source);\n\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (source != null && typeof source !== 'number' && 'uri' in source && typeof source.uri === 'string') {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (source != null && typeof source !== 'number' && 'overrideFileExtensionAndroid' in source && typeof source.overrideFileExtensionAndroid === 'string') {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (source != null && typeof source !== 'number' && 'headers' in source && typeof source.headers === 'object') {\n    headers = source.headers;\n  }\n\n  return {\n    uri: uri,\n    overridingExtension: overridingExtension,\n    headers: headers\n  };\n}\n\nfunction _getAssetFromPlaybackSource(source) {\n  if (source == null) {\n    return null;\n  }\n\n  var asset = null;\n\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n\n  return asset;\n}\n\nexport function assertStatusValuesInBounds(status) {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\nexport function getNativeSourceAndFullInitialStatusForLoadAsync(_x, _x2, _x3) {\n  return _getNativeSourceAndFullInitialStatusForLoadAsync.apply(this, arguments);\n}\n\nfunction _getNativeSourceAndFullInitialStatusForLoadAsync() {\n  _getNativeSourceAndFullInitialStatusForLoadAsync = _asyncToGenerator(function* (source, initialStatus, downloadFirst) {\n    var fullInitialStatus = initialStatus == null ? _DEFAULT_INITIAL_PLAYBACK_STATUS : _objectSpread(_objectSpread({}, _DEFAULT_INITIAL_PLAYBACK_STATUS), initialStatus);\n    assertStatusValuesInBounds(fullInitialStatus);\n\n    if (typeof source === 'string' && Platform.OS === 'web') {\n      return {\n        nativeSource: {\n          uri: source,\n          overridingExtension: null\n        },\n        fullInitialStatus: fullInitialStatus\n      };\n    }\n\n    var asset = _getAssetFromPlaybackSource(source);\n\n    if (downloadFirst && asset) {\n      yield asset.downloadAsync();\n    }\n\n    var nativeSource = getNativeSourceFromSource(source);\n\n    if (nativeSource === null) {\n      throw new Error(\"Cannot load an AV asset from a null playback source\");\n    }\n\n    if (asset && asset.localUri) {\n      nativeSource.uri = asset.localUri;\n    }\n\n    return {\n      nativeSource: nativeSource,\n      fullInitialStatus: fullInitialStatus\n    };\n  });\n  return _getNativeSourceAndFullInitialStatusForLoadAsync.apply(this, arguments);\n}\n\nexport function getUnloadedStatus() {\n  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return _objectSpread({\n    isLoaded: false\n  }, error ? {\n    error: error\n  } : null);\n}\nexport var PlaybackMixin = {\n  playAsync: function () {\n    var _playAsync = _asyncToGenerator(function* () {\n      return this.setStatusAsync({\n        shouldPlay: true\n      });\n    });\n\n    function playAsync() {\n      return _playAsync.apply(this, arguments);\n    }\n\n    return playAsync;\n  }(),\n  playFromPositionAsync: function () {\n    var _playFromPositionAsync = _asyncToGenerator(function* (positionMillis) {\n      var tolerances = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setStatusAsync({\n        positionMillis: positionMillis,\n        shouldPlay: true,\n        seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n        seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n      });\n    });\n\n    function playFromPositionAsync(_x4) {\n      return _playFromPositionAsync.apply(this, arguments);\n    }\n\n    return playFromPositionAsync;\n  }(),\n  pauseAsync: function () {\n    var _pauseAsync = _asyncToGenerator(function* () {\n      return this.setStatusAsync({\n        shouldPlay: false\n      });\n    });\n\n    function pauseAsync() {\n      return _pauseAsync.apply(this, arguments);\n    }\n\n    return pauseAsync;\n  }(),\n  stopAsync: function () {\n    var _stopAsync = _asyncToGenerator(function* () {\n      return this.setStatusAsync({\n        positionMillis: 0,\n        shouldPlay: false\n      });\n    });\n\n    function stopAsync() {\n      return _stopAsync.apply(this, arguments);\n    }\n\n    return stopAsync;\n  }(),\n  setPositionAsync: function () {\n    var _setPositionAsync = _asyncToGenerator(function* (positionMillis) {\n      var tolerances = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setStatusAsync({\n        positionMillis: positionMillis,\n        seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n        seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n      });\n    });\n\n    function setPositionAsync(_x5) {\n      return _setPositionAsync.apply(this, arguments);\n    }\n\n    return setPositionAsync;\n  }(),\n  setRateAsync: function () {\n    var _setRateAsync = _asyncToGenerator(function* (rate) {\n      var shouldCorrectPitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var pitchCorrectionQuality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PitchCorrectionQuality.Low;\n      return this.setStatusAsync({\n        rate: rate,\n        shouldCorrectPitch: shouldCorrectPitch,\n        pitchCorrectionQuality: pitchCorrectionQuality\n      });\n    });\n\n    function setRateAsync(_x6) {\n      return _setRateAsync.apply(this, arguments);\n    }\n\n    return setRateAsync;\n  }(),\n  setVolumeAsync: function () {\n    var _setVolumeAsync = _asyncToGenerator(function* (volume) {\n      return this.setStatusAsync({\n        volume: volume\n      });\n    });\n\n    function setVolumeAsync(_x7) {\n      return _setVolumeAsync.apply(this, arguments);\n    }\n\n    return setVolumeAsync;\n  }(),\n  setIsMutedAsync: function () {\n    var _setIsMutedAsync = _asyncToGenerator(function* (isMuted) {\n      return this.setStatusAsync({\n        isMuted: isMuted\n      });\n    });\n\n    function setIsMutedAsync(_x8) {\n      return _setIsMutedAsync.apply(this, arguments);\n    }\n\n    return setIsMutedAsync;\n  }(),\n  setIsLoopingAsync: function () {\n    var _setIsLoopingAsync = _asyncToGenerator(function* (isLooping) {\n      return this.setStatusAsync({\n        isLooping: isLooping\n      });\n    });\n\n    function setIsLoopingAsync(_x9) {\n      return _setIsLoopingAsync.apply(this, arguments);\n    }\n\n    return setIsLoopingAsync;\n  }(),\n  setProgressUpdateIntervalAsync: function () {\n    var _setProgressUpdateIntervalAsync = _asyncToGenerator(function* (progressUpdateIntervalMillis) {\n      return this.setStatusAsync({\n        progressUpdateIntervalMillis: progressUpdateIntervalMillis\n      });\n    });\n\n    function setProgressUpdateIntervalAsync(_x10) {\n      return _setProgressUpdateIntervalAsync.apply(this, arguments);\n    }\n\n    return setProgressUpdateIntervalAsync;\n  }()\n};\nexport * from \"./AV.types\";","map":{"version":3,"sources":["../src/AV.ts"],"names":[],"mappings":"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","sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n  AVPlaybackTolerance,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\n\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false,\n};\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: AVPlaybackNativeSource['headers'];\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\n// @needsAudit\nexport interface AV {\n  /**\n   * Sets a new `AVPlaybackStatusToSet` on the `playbackObject`. This method can only be called if the media has been loaded.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed. See below for details on `AVPlaybackStatus`.\n   */\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * Gets the `AVPlaybackStatus` of the `playbackObject`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject`.\n   */\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\n// @needsAudit\n/**\n * On the `playbackObject` reference, the following API is provided.\n */\nexport interface Playback extends AV {\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   */\n  playAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Loads the media from `source` into memory and prepares it for playing. This must be called before calling `setStatusAsync()`\n   * or any of the convenience set status methods. This method can only be called if the `playbackObject` is in an unloaded state.\n   * @param source The source of the media.\n   * @param initialStatus The initial intended `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. For more information see the details on `AVPlaybackStatusToSet` type\n   * and the default initial playback status.\n   * @param downloadAsync If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `true`. Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is loaded, or rejects if loading failed.\n   * The `Promise` will also reject if the `playbackObject` was already loaded. See below for details on `AVPlaybackStatus`.\n   */\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus?: AVPlaybackStatusToSet,\n    downloadAsync?: boolean\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * Unloads the media from memory. `loadAsync()` must be called again in order to be able to play the media.\n   * > This cleanup function will be automatically called in the `Video` component's `componentWillUnmount`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is unloaded, or rejects if unloading failed.\n   */\n  unloadAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true, positionMillis, seekMillisToleranceAfter: tolerances.seekMillisToleranceAfter, seekMillisToleranceBefore: tolerances.seekMillisToleranceBefore })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false })`.\n   */\n  pauseAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false, positionMillis: 0 })`.\n   */\n  stopAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Replays the playback item. When using `playFromPositionAsync(0)` the item is seeked to the position at `0 ms`.\n   * On iOS this method uses internal implementation of the player and is able to play the item from the beginning immediately.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * `positionMillis` and `shouldPlay` properties will be overridden with respectively `0` and `true`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed.\n   */\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ positionMillis })`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ rate, shouldCorrectPitch, pitchCorrectionQuality })`.\n   * @param rate The desired playback rate of the media. This value must be between `0.0` and `32.0`. Only available on Android API version 23 and later and iOS.\n   * @param shouldCorrectPitch A boolean describing if we should correct the pitch for a changed rate. If set to `true`, the pitch of the audio will be corrected\n   * (so a rate different than `1.0` will timestretch the audio).\n   * @param pitchCorrectionQuality iOS time pitch algorithm setting, defaults to `Audio.PitchCorrectionQuality.Low`.\n   */\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ volume })`.\n   * @param volume A number between `0.0` (silence) and `1.0` (maximum volume).\n   */\n  setVolumeAsync(volume: number): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isMuted })`.\n   * @param isMuted A boolean describing if the audio of this media should be muted.\n   */\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isLooping })`.\n   * @param isLooping A boolean describing if the media should play once (`false`) or loop indefinitely (`true`).\n   */\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ progressUpdateIntervalMillis })`.\n   * @param progressUpdateIntervalMillis The new minimum interval in milliseconds between calls of `onPlaybackStatusUpdate`.\n   * See `setOnPlaybackStatusUpdate()` for details.\n   */\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Low\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}