{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { PermissionStatus, createPermissionHook, EventEmitter, Platform } from 'expo-modules-core';\nimport { _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS } from \"../AV\";\nimport ExponentAV from \"../ExponentAV\";\nimport { isAudioEnabled, throwIfAudioIsDisabled } from \"./AudioAvailability\";\nimport { RecordingOptionsPresets } from \"./RecordingConstants\";\nimport { Sound } from \"./Sound\";\nvar _recorderExists = false;\nvar eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\nexport function getPermissionsAsync() {\n  return _getPermissionsAsync.apply(this, arguments);\n}\n\nfunction _getPermissionsAsync() {\n  _getPermissionsAsync = _asyncToGenerator(function* () {\n    return ExponentAV.getPermissionsAsync();\n  });\n  return _getPermissionsAsync.apply(this, arguments);\n}\n\nexport function requestPermissionsAsync() {\n  return _requestPermissionsAsync.apply(this, arguments);\n}\n\nfunction _requestPermissionsAsync() {\n  _requestPermissionsAsync = _asyncToGenerator(function* () {\n    return ExponentAV.requestPermissionsAsync();\n  });\n  return _requestPermissionsAsync.apply(this, arguments);\n}\n\nexport var usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync\n});\nexport var Recording = function () {\n  function Recording() {\n    var _this = this;\n\n    _classCallCheck(this, Recording);\n\n    this._subscription = null;\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n\n    this._cleanupForUnloadedRecorder = function () {\n      var _ref = _asyncToGenerator(function* (finalStatus) {\n        var _finalStatus$duration;\n\n        _this._canRecord = false;\n        _this._isDoneRecording = true;\n        _this._finalDurationMillis = (_finalStatus$duration = finalStatus == null ? void 0 : finalStatus.durationMillis) != null ? _finalStatus$duration : 0;\n        _recorderExists = false;\n\n        if (_this._subscription) {\n          _this._subscription.remove();\n\n          _this._subscription = null;\n        }\n\n        _this._disablePolling();\n\n        return yield _this.getStatusAsync();\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this._pollingLoop = _asyncToGenerator(function* () {\n      if (isAudioEnabled() && _this._canRecord && _this._onRecordingStatusUpdate != null) {\n        _this._progressUpdateTimeoutVariable = setTimeout(_this._pollingLoop, _this._progressUpdateIntervalMillis);\n\n        try {\n          yield _this.getStatusAsync();\n        } catch (_unused) {\n          _this._disablePolling();\n        }\n      }\n    });\n    this.getStatusAsync = _asyncToGenerator(function* () {\n      if (_this._canRecord) {\n        return _this._performOperationAndHandleStatusAsync(function () {\n          return ExponentAV.getAudioRecordingStatus();\n        });\n      }\n\n      var status = {\n        canRecord: false,\n        isRecording: false,\n        isDoneRecording: _this._isDoneRecording,\n        durationMillis: _this._finalDurationMillis\n      };\n\n      _this._callOnRecordingStatusUpdateForNewStatus(status);\n\n      return status;\n    });\n  }\n\n  _createClass(Recording, [{\n    key: \"_disablePolling\",\n    value: function _disablePolling() {\n      if (this._progressUpdateTimeoutVariable != null) {\n        clearTimeout(this._progressUpdateTimeoutVariable);\n        this._progressUpdateTimeoutVariable = null;\n      }\n    }\n  }, {\n    key: \"_enablePollingIfNecessaryAndPossible\",\n    value: function _enablePollingIfNecessaryAndPossible() {\n      if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n        this._disablePolling();\n\n        this._pollingLoop();\n      }\n    }\n  }, {\n    key: \"_callOnRecordingStatusUpdateForNewStatus\",\n    value: function _callOnRecordingStatusUpdateForNewStatus(status) {\n      if (this._onRecordingStatusUpdate != null) {\n        this._onRecordingStatusUpdate(status);\n      }\n    }\n  }, {\n    key: \"_performOperationAndHandleStatusAsync\",\n    value: function () {\n      var _performOperationAndHandleStatusAsync2 = _asyncToGenerator(function* (operation) {\n        throwIfAudioIsDisabled();\n\n        if (this._canRecord) {\n          var status = yield operation();\n\n          this._callOnRecordingStatusUpdateForNewStatus(status);\n\n          return status;\n        } else {\n          throw new Error('Cannot complete operation because this recorder is not ready to record.');\n        }\n      });\n\n      function _performOperationAndHandleStatusAsync(_x2) {\n        return _performOperationAndHandleStatusAsync2.apply(this, arguments);\n      }\n\n      return _performOperationAndHandleStatusAsync;\n    }()\n  }, {\n    key: \"setOnRecordingStatusUpdate\",\n    value: function setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n      this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n\n      if (onRecordingStatusUpdate == null) {\n        this._disablePolling();\n      } else {\n        this._enablePollingIfNecessaryAndPossible();\n      }\n\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"setProgressUpdateInterval\",\n    value: function setProgressUpdateInterval(progressUpdateIntervalMillis) {\n      this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"prepareToRecordAsync\",\n    value: function () {\n      var _prepareToRecordAsync = _asyncToGenerator(function* () {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RecordingOptionsPresets.LOW_QUALITY;\n        throwIfAudioIsDisabled();\n\n        if (_recorderExists) {\n          throw new Error('Only one Recording object can be prepared at a given time.');\n        }\n\n        if (this._isDoneRecording) {\n          throw new Error('This Recording object is done recording; you must make a new one.');\n        }\n\n        if (!options || !options.android || !options.ios) {\n          throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n        }\n\n        var extensionRegex = /^\\.\\w+$/;\n\n        if (!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension)) {\n          throw new Error(\"Your file extensions must match \" + extensionRegex.toString() + \".\");\n        }\n\n        if (!this._canRecord) {\n          if (eventEmitter) {\n            this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n          }\n\n          var _yield$ExponentAV$pre = yield ExponentAV.prepareAudioRecorder(options),\n              uri = _yield$ExponentAV$pre.uri,\n              status = _yield$ExponentAV$pre.status;\n\n          _recorderExists = true;\n          this._uri = uri;\n          this._options = options;\n          this._canRecord = true;\n\n          var currentStatus = _objectSpread(_objectSpread({}, status), {}, {\n            canRecord: true\n          });\n\n          this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n\n          this._enablePollingIfNecessaryAndPossible();\n\n          return currentStatus;\n        } else {\n          throw new Error('This Recording object is already prepared to record.');\n        }\n      });\n\n      function prepareToRecordAsync() {\n        return _prepareToRecordAsync.apply(this, arguments);\n      }\n\n      return prepareToRecordAsync;\n    }()\n  }, {\n    key: \"getAvailableInputs\",\n    value: function () {\n      var _getAvailableInputs = _asyncToGenerator(function* () {\n        return ExponentAV.getAvailableInputs();\n      });\n\n      function getAvailableInputs() {\n        return _getAvailableInputs.apply(this, arguments);\n      }\n\n      return getAvailableInputs;\n    }()\n  }, {\n    key: \"getCurrentInput\",\n    value: function () {\n      var _getCurrentInput = _asyncToGenerator(function* () {\n        return ExponentAV.getCurrentInput();\n      });\n\n      function getCurrentInput() {\n        return _getCurrentInput.apply(this, arguments);\n      }\n\n      return getCurrentInput;\n    }()\n  }, {\n    key: \"setInput\",\n    value: function () {\n      var _setInput = _asyncToGenerator(function* (inputUid) {\n        return ExponentAV.setInput(inputUid);\n      });\n\n      function setInput(_x3) {\n        return _setInput.apply(this, arguments);\n      }\n\n      return setInput;\n    }()\n  }, {\n    key: \"startAsync\",\n    value: function () {\n      var _startAsync = _asyncToGenerator(function* () {\n        return this._performOperationAndHandleStatusAsync(function () {\n          return ExponentAV.startAudioRecording();\n        });\n      });\n\n      function startAsync() {\n        return _startAsync.apply(this, arguments);\n      }\n\n      return startAsync;\n    }()\n  }, {\n    key: \"pauseAsync\",\n    value: function () {\n      var _pauseAsync = _asyncToGenerator(function* () {\n        return this._performOperationAndHandleStatusAsync(function () {\n          return ExponentAV.pauseAudioRecording();\n        });\n      });\n\n      function pauseAsync() {\n        return _pauseAsync.apply(this, arguments);\n      }\n\n      return pauseAsync;\n    }()\n  }, {\n    key: \"stopAndUnloadAsync\",\n    value: function () {\n      var _stopAndUnloadAsync = _asyncToGenerator(function* () {\n        var _stopResult;\n\n        if (!this._canRecord) {\n          if (this._isDoneRecording) {\n            throw new Error('Cannot unload a Recording that has already been unloaded.');\n          } else {\n            throw new Error('Cannot unload a Recording that has not been prepared.');\n          }\n        }\n\n        var stopResult;\n        var stopError;\n\n        try {\n          stopResult = yield ExponentAV.stopAudioRecording();\n        } catch (err) {\n          stopError = err;\n        }\n\n        if (Platform.OS === 'web' && ((_stopResult = stopResult) == null ? void 0 : _stopResult.uri) !== undefined) {\n          this._uri = stopResult.uri;\n        }\n\n        yield ExponentAV.unloadAudioRecorder();\n        var status = yield this._cleanupForUnloadedRecorder(stopResult);\n        return stopError ? Promise.reject(stopError) : status;\n      });\n\n      function stopAndUnloadAsync() {\n        return _stopAndUnloadAsync.apply(this, arguments);\n      }\n\n      return stopAndUnloadAsync;\n    }()\n  }, {\n    key: \"getURI\",\n    value: function getURI() {\n      return this._uri;\n    }\n  }, {\n    key: \"createNewLoadedSound\",\n    value: function () {\n      var _createNewLoadedSound = _asyncToGenerator(function* () {\n        var initialStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var onPlaybackStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");\n        return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n      });\n\n      function createNewLoadedSound() {\n        return _createNewLoadedSound.apply(this, arguments);\n      }\n\n      return createNewLoadedSound;\n    }()\n  }, {\n    key: \"createNewLoadedSoundAsync\",\n    value: function () {\n      var _createNewLoadedSoundAsync = _asyncToGenerator(function* () {\n        var initialStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var onPlaybackStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (this._uri == null || !this._isDoneRecording) {\n          throw new Error('Cannot create sound when the Recording has not finished!');\n        }\n\n        return Sound.createAsync({\n          uri: this._uri\n        }, initialStatus, onPlaybackStatusUpdate, false);\n      });\n\n      function createNewLoadedSoundAsync() {\n        return _createNewLoadedSoundAsync.apply(this, arguments);\n      }\n\n      return createNewLoadedSoundAsync;\n    }()\n  }]);\n\n  return Recording;\n}();\nRecording.createAsync = _asyncToGenerator(function* () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RecordingOptionsPresets.LOW_QUALITY;\n  var onRecordingStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var progressUpdateIntervalMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var recording = new Recording();\n\n  if (progressUpdateIntervalMillis) {\n    recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n  }\n\n  recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n  yield recording.prepareToRecordAsync(_objectSpread(_objectSpread({}, options), {}, {\n    keepAudioActiveHint: true\n  }));\n\n  try {\n    var status = yield recording.startAsync();\n    return {\n      recording: recording,\n      status: status\n    };\n  } catch (err) {\n    recording.stopAndUnloadAsync();\n    throw err;\n  }\n});\nexport { PermissionStatus };\nexport * from \"./RecordingConstants\";\nexport * from \"./Recording.types\";","map":{"version":3,"sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  RecordingInput,\n  RecordingObject,\n  RecordingOptions,\n  RecordingStatus,\n} from './Recording.types';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound, SoundObject } from './Sound';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n */\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async (\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<RecordingObject> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync(\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs(): Promise<RecordingInput[]> {\n    return ExponentAV.getAvailableInputs();\n  }\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput(): Promise<RecordingInput> {\n    return ExponentAV.getCurrentInput();\n  }\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid: string): Promise<void> {\n    return ExponentAV.setInput(inputUid);\n  }\n\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\nexport * from './RecordingConstants';\n\nexport * from './Recording.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}